#!/usr/bin/perl

if ('' cmp 'DOC SYNOPSIS') {

=pod

=head1 NAME

compile-latex - compile files until reaching a fixed point

=head1 SYNOPSIS

compile-latex B<--help>|B<--man>|B<--nroff>|B<--usage>

compile-latex B<[--action build|--build]> I<goals and options>

compile-latex B<--action in|out|intermediary|ignore> I<goals>

End of synopsis

=cut

}
if ('' cmp 'DOC PRINCIPLE') {

=pod

=head1 PRINCIPLE

C<compile-latex> acts mostly as your usual (La)TeX-compiling command but
tries instead to compile the given files up to a fixed point. To reach
this goal, C<compile-latex> also executes the two main ancillary
programs of TeX: C<bibtex> and C<makeindex> (even multiple times if
there are multiple indices or multiple bibliographic sections).

The fixed point is considered globally. C<compile-latex> will
automatically find out the files written by TeX and wait for these to
stabilize.

Moreover, C<compile-latex> is capable of compiling in one command
multiple source files, each under different jobnames. Options for
compiling may apply only to one jobname (and thus to one source file) or
globally, according to their position on the command line : all options
given after the last source file will apply globally, all options given
after the last jobname (if any) but before the source file will apply to
all jobnames for this source file only. For some options (such as action
selection), the choice is always global. Last, all options given before
a jobname will apply only to this jobname.

The fixed-point is not a real fixed-point, because (for example) PDF
generated by TeX do change with each run (they have associated
timestamps). What matters is that before compiling, all input files and
output files are the same as before the previous run (this says that it
is not useful to rerun the

C<compile-latex> splits the files it deals with in four categories:

=over

=item * B<in> files are read by the process, but not rewritten.

=item * B<out> files are written by the process, but not reread.

=item * B<intermediary> files are both read and written by the process.

=item * B<ignore> are files that are ignored for the purpose of
fixed-point (log files, mostly).

=back

Input files and output files are discovered automatically for the TeX
process and the bibtex process. Due to the nature of the makeindex
process, the input and output have to be given by the user. However, the
typical C<.idx => .ind> index is tried automatically. The C<bibtex> and
C<makeindex> automatic processing can be disabled if desired with the
C<--manual> option.

This discovery process may lead to one more compilation sometimes, if
the process discovers new files during a compilation that it did not
anticipate.

The information about the compilation process is stored in a hidden
subdirectory of the source file directory: B<.compile-latex/I<jobname>>.

There is a global action to not change directory for the one of the
source: C<--no-chdir>. Remark that relative paths in the source file
will therefore start from the place of compilation, which may cause
trouble.

=head1 ACTIONS

Besides compiling your files, C<compile-latex> can also do other
actions. Actions are selected by options equivalent to a C<--action
action_name>, the name being one of:

=over

=item * B<build> the default action if none other is specified: compile

=item * B<in>, B<out>, B<intermediary>, B<ignore> list files matching
the action name.

=item * B<gitignore> outputs a C<.gitignore> file for all generated files.

=item * B<cli> (experimental) returns a command-line doing exactly the
same thing as the current command line.

=item * B<clean> (experimental) removes all or part of generated files
(controlled by C<--clean-mode>) option. B<--distclean> is equivalent to
C<--clean-mode all --action clean>.

=back

=head1 OPTIONS REFERENCE

=head2 ACTIONS

The actions are global options that specify the work to be done on the
otherwise specified goals. They are specified as B<--action
I<actionname>> or equivalently B<--I<actionname>>. The basic option is
B<build> and iterates the commands necessary to build the result files.

The dump actions B<in>, B<out>, B<intermediary> and B<ignore> will dump
all files of the same name. The files are not split by source, jobname
or anything. If this is required, several calls to C<compile-latex> are
required. Remark that this list is guaranteed to be correct only if a
successful compilation took place (with B<build> action, either in the
same run or in previous run).

The B<gitignore> action will generate a C<.gitignore> file for all
generated files. As above, this list will be correct only if made after
a successful build.

=head2 ANTICIPATING INPUTS AND OUTPUTS

To avoid (at most) one cycle of compilation, it is possible to give to
C<compile-latex> advance information about the files that are going to
be read. This is often more cumbersome to do than compiling one more
time, but the B<--action cli> mode outputs just the right information so
that you may record this command line in a Makefile or something else.

If this advance information is false, the automatic discovery of
dependencies will fix the error after the first compilation.

The command line switches are B<--assume-in>, B<--assume-out>,
B<--assume-intermediary>, B<--assume-ignore>, each followed by one file
name.

=head2 VARIANTS

The variants correspond to different ways of compiling TeX files.

The default variant is equivalent to B<--variant pdflatex>. Other
possible variants are B<dvips> (or B<dvips+latex>), B<dvipdf> (or
B<dvipdf+latex>), B<dvipdfm> (or B<dvipdfm+latex>), B<xelatex> or
B<lualatex>. Other variants exist by substituting tex for latex (in
which case TeX is used instead of LaTeX).

=head2 MISCELLANEOUS OPTIONS

The B<--filter> option allows to filter out most output of LaTeX unless
input is required or an error occurs. The B<--no-filter> cancels this
out (see L</"OUTPUT OPTIONS">).

The B<--chdir> option allows to compilation to change to the source file
directory just before compilation. Paths therefore are relative to the
source file, not to the place of compilation. The B<--no-chdir> prevents
this default behavior.

The B<--generated> option is synonymous for B<--action out --action
intermediary> and outputs

The B<--quiet> option sets various verbosity option to be as quiet as
possible.

=head2 INDEX OPTIONS

Various options apply to the index generation. All options apply up to
the next B<--index-output> option. If elements are missing, they will be
assumed to be the standard C<.idx => .ind> index.

The B<-suffix> options add the given suffix to the job name instead of
taking the argument as a whole file. The I<usual> way of making an index
is thus B<--index-output-suffix .ind --index-input-suffix .idx>.

The index options are

=over

=item * B<index-output[-suffix]> the output of the makeindex command

=item * B<index-input[-suffix]> the input of the makeindex command

=item * B<index-style[-suffix]> the style of the makeindex command

=item * B<index-log[-suffix]> the log output of the makeindex command

=item * B<index-options> some more options to makeindex (separated by spaces)

=back

=head2 BIBLIOGRAPHY OPTIONS

Since in automatic mode (without B<--manual>) all bibtex-able files are
automatically discovered and processed, these options are not often
useful.

B<--bibtex-file> is followed by the name of a file to be processed by
bibtex. B<--bibtex-file-suffix> is the same but only the suffix to
the job name has to be passed.

B<--bibtex> is synonymous for B<--bibtex-file-suffix .aux>.

B<--bibtex-program> is followed by a (space-separated) string to call
the BibTeX executable. Default is just C<bibtex>.

=cut

}

use strict;use warnings;
# Unicode safety
use utf8;use Encode;
use JSON::PP;use Data::Dumper;
use Digest::MD5;
use Term::ANSIColor;
use File::Path qw(make_path remove_tree);use Cwd qw(getcwd realpath);
# command execution
use Symbol 'gensym';use IPC::Open3;
use POSIX qw(:sys_wait_h dup dup2);use IO::Select;use IO::Handle;

my ($sourceContext,$optionContext,$execContext,$outContext,$progContext);

$progContext={'tmpfiles' => {}, 'in'=> {}, 'out' => {} , 'intermediary' => {}, 'ignore' => {}};

# Convenience

sub clone {
  my $obj=shift @_;
  my $t=ref($obj);
  return $obj unless ($t);
  return [map {&clone($_)} @$obj] if ($t eq 'ARRAY');
  my $n={};
  foreach my $key (keys %$obj) {
    $n->{$key}=&clone($obj->{$key});
  }
  return $n;
}

sub addHash {
  my $hash={};
  foreach my $h (@_) {
    foreach my $k (keys %$h) {
      $hash->{$k}=1;
    }
  }
  return $hash;
}
sub addHashInPlace {
  my $hash=shift @_;
  foreach my $h (@_) {
    foreach my $k (keys %$h) {
      $hash->{$k}=$h->{$k};
    }
  }
}
sub subHash {
  my $hash={};    # TODO optimize if first hash much larger than second?
  my $init=shift @_;
  foreach my $k (keys %$init) {
    $hash->{$k}=1;
  }
  foreach my $h (@_) {
    foreach my $k (keys %$h) {
      delete ($hash->{$k}) if (exists($hash->{$k}));
    }
  }
  return $hash;
}

sub main {
  &initLogging();
  &parseARGV();
  my $actions=$optionContext->{'actions'};
  if (defined($actions->{'help'})) {
    &usage($optionContext->{'help'});
  }
  &setupCommand();
  foreach my $sourcefile (sort keys %{$optionContext->{'includedFiles'}}) {
    &processSourcefile($sourcefile);
  }
  foreach my $i ('in','out','intermediary','ignore') {
    if (defined($optionContext->{'actions'}->{$i})) {
      foreach my $key (sort keys %{$progContext->{$i}}) {
        &out(1,'result',&encodeGoalLine($key));
      }
    }
  }
  if (defined($optionContext->{'actions'}->{'gitignore'})) {
    foreach my $key (sort keys %{$progContext->{'gitignore'}}) {
      my $data='/'.join("\n/",sort keys %{$progContext->{'gitignore'}->{$key}});
      &outputSection('.gitignore',"compile-latex:$key",$data);
    }
  }
  if (defined($optionContext->{'actions'}->{'clean'})) {
    my $mode=$optionContext->{'cleanMode'};
    my $removed=0;
    foreach my $key (sort keys %{$progContext->{'gitignore'}}) {
      foreach my $file (sort keys %{$progContext->{'gitignore'}->{$key}}) {
        if (($mode eq 'simple' or $mode eq 'all') and
            !defined($progContext->{'latexresult'}->{$file}) and
            !defined($progContext->{'metadirs'}->{$file})
           ) {
          if (-f $file) {
            unlink $file;
            $removed++;
          }
        } elsif (($mode eq 'meta' or $mode eq 'all') and defined($progContext->{'metadirs'}->{$file})) {
          if (-d $file) {
            remove_tree($file);
            $removed++;
          }
        } elsif (($mode eq 'result' or $mode eq 'all') and defined($progContext->{'latexresult'}->{$file})) {
          if (-f $file) {
            unlink $file;
            $removed++;
          }
        }
      }
    }
    &out(3,'display',"removed $removed files");
  }
  foreach my $i ('cli') {
    if (defined($optionContext->{'actions'}->{$i})) {
      foreach my $key (keys %{$progContext->{$i}}) {
        &out(1,'result',$key.";".$progContext->{$i}->{$key});
      }
    }
  }
  &finish(0);
}

&main();

# Logging
sub initLogging {

=pod

=head2 OUTPUT OPTIONS

B<--verbosity> I<category> I<level> Change the verbosity to I<level> in I<category>.

B<--I<category>> I<level> Shortcut, as above.

If verbosity can be mistaken for a target name, use the B<--verbosity>
form, because the target will take precedence.

The verbosity level is a positive integer (including 0).


The various categories are :

=over

=item * B<init> initialization information (not useful)

=item * B<plan> informations about the building plan (can be very verbose)

=item * B<exec> informations about the commands launched by the plan

=item * B<err> the error output of the various commands

=item * B<out> the console output of the various commands

=item * B<display> the summary of the execution of the plan (1: only
source files, 2: also jobnames, 3: each command (default))

=item * B<result> the result of actions such as B<out>, B<in> or B<intermediary>.

=back

Each rule can define a class and a subclass, and each item built will be
output in a synthetic manner. The default setting is 3 for B<display>, 1
for B<what> and 1 for B<out> and B<err>. A quiet effect can be obtained
by setting everything to 0.

The B<--filter> option allows intelligent filtering on the TeX output
(which is very difficult to parse). If some possible error message is
detected (possibly leading to user input), the output will be fully
printed. Else, nothing will be printed.

=cut

  binmode(STDOUT,':utf8');
  binmode(STDERR,':utf8');
  binmode(STDIN,':utf8');
  my $verbosity={'exec'=>0,
                 'init'=>0,
                 'plan'=>0,
                 'result'=>1,
                 'out'=>1,
                 'err'=>1,
                 'dev'=>1,
                 'display'=>3};
  my $jsonEncoder=JSON::PP->new->utf8->pretty->canonical;
  $outContext={
               'color' => 1,
               'class' => '',
               'subclass' => '',
               'currentcol' => 0,
               'nomove' => 0,
               'countphase' => '',
               'lastcountcol' => 0,
               'verbosity' => $verbosity,
               'specialprefix' => qr/^PARTIAL PLAN:(.*)$/,
               'json' => $jsonEncoder,
               'outString' => ''
              };
  &columns();
  $SIG{WINCH} = sub { &columns(); };
  $ENV{'SPECIALPREFIX'}="PARTIAL PLAN:";
  $outContext->{'color'}=0 unless -t STDOUT;
  &out(1,'init','Logging system ready');
}                               # DOC INSIDE
sub columns {
  require 'sys/ioctl.ph';
  my $winsize;
  die 'no TIOCGWINSZ' unless defined &TIOCGWINSZ;
  open(TTY, "+</dev/tty") or die "No tty: $!";
  unless (ioctl(TTY, &TIOCGWINSZ, $winsize='')) {
    die sprintf "$0: ioctl TIOCGWINSZ (%08x: $!)\n", &TIOCGWINSZ;
  }
  my ($row, $col, $xpixel, $ypixel) = unpack('S4', $winsize);
  $outContext->{'columns'}=$col;
}
sub finish {
  my $status=shift @_;
  &newline();
  if ($status) {
    print "Dying: ",@_,"\n";
  }
  foreach my $key (keys %{$progContext->{'tmpfiles'}}) {
    unlink($key);
  }
  exit($status);
}
sub newline {
  print "\n" if ($outContext->{'currentcol'});
  $outContext->{'currentcol'}=0;
  $outContext->{'nomove'}=0;
}
sub class {
  my $class=$_[0];
  if ($class ne $outContext->{'class'}) {
    &newline();
    $outContext->{'subclass'}='';
    print color 'bold' if ($outContext->{'color'});
    print $class,"\n";
    print color 'reset' if ($outContext->{'color'});
    $outContext->{'class'}=$class;
  }
}
sub subclass {
  my $subclass=$_[0];
  if ($subclass ne $outContext->{'subclass'}) {
    $outContext->{'subclass'}=$subclass;
    print color 'bold' if ($outContext->{'color'});
    &outDisplay($subclass);
    print color 'reset' if ($outContext->{'color'});
  }
}
sub outDisplay {
  my $str=join('',@_);
  my $storepos=0;
  if ($str =~ /^subclass:(.*)$/) {
    &subclass($1);
    return;
  }
  if ($str =~ /^count:(.*):([0-9\/]+)$/) {
    $str="$1:$2";
    my $oldcountphase=$outContext->{'countphase'};
    my $countphase="$1";
    $outContext->{'countphase'}=$countphase;
    if ($outContext->{'color'} == 0) {
      my $lastcountcol=$outContext->{'lastcountcol'}+1;
      if ($lastcountcol == 500) {
        $lastcountcol=0;
      }
      if ($countphase ne $oldcountphase) {
        $lastcountcol=0;
      }
      $outContext->{'lastcountcol'}=$lastcountcol;
      return if ($lastcountcol != 0);
    } else {
      if ($outContext->{'nomove'} == 1 and $countphase eq $oldcountphase) {
        $storepos=2;
      } else {
        $storepos=1;
      }
    }
  } else {
    $outContext->{'countphase'}='';
  }
  if ($storepos == 2) {
    $outContext->{'nomove'}=1;
    $outContext->{'currentcol'}=$outContext->{'lastcountcol'};
    print "\x1b[u";
  }
  my $len=length($str);
  my $margin=2;                 # Two chars required for []
  if ($outContext->{'currentcol'}+$margin+$len>$outContext->{'columns'}) {
    &newline();
  }
  if ($outContext->{'currentcol'}==0) {
    print '    ';
    $outContext->{'currentcol'}=4;
  }
  if ($storepos == 1) {
    $outContext->{'nomove'}=1;
    $outContext->{'lastcountcol'}=$outContext->{'currentcol'};
    print "\x1b[s";
  } elsif ($storepos != 2) {
    $outContext->{'nomove'}=0;
  }
  $outContext->{'currentcol'}+=2+$len;
  print '[',$str,']';
}
sub out {
  my $v=shift @_;
  my $n=shift @_;
  if ($outContext->{'verbosity'}->{$n}>=$v) {
    if (ref($_[0])) {
      $_[1] = Data::Dumper->Dump([$_[0]],[$_[1]]);
      shift @_;
    }
    if ($n eq 'display') {
      my $storepos=0;
      if ($v==1) {
        &class(@_);
      } elsif ($v==2) {
        &subclass(@_);
      } else {
        &outDisplay(@_);
      }
    } elsif ($n eq 'result') {
      &newline();
      print @_,"\n";
    } elsif ($n eq 'out') {
      $outContext->{'outString'}.=join('',@_);
    } elsif ($n eq 'err' or $n eq 'dev') {
      &newline();
      print color 'red' if ($outContext->{'color'});
      print @_,"\n";
      print color 'reset' if ($outContext->{'color'});
    } else {
      &newline();
      print $n,':',@_,"\n";
    }
  }
}
sub outIdle() {
  my $out=$outContext->{'outString'};
  my @fulllines=();
  while ($out=~m|^([^\n]*\n)(.*)$|gs) {
    push @fulllines,$1;
    $out=$2;
  }
  my $alert=0;
  if (length($out) and
      defined($outContext->{'outIdle'}) and
      (time-$outContext->{'outIdle'})>2) {
    push @fulllines,$out;
    $out='';
  }
  goto END unless (scalar @fulllines);
  if ($outContext->{'filter'}) {
    $outContext->{'outStringPast'}=[] unless defined($outContext->{'outStringPast'});
    my $past=$outContext->{'outStringPast'};
    my $alert=0;
    foreach my $line (@fulllines) {
      push $past,$line;
      if ($line=~/^([^:]*):[0-9]+: (.*)\.$/) {
        $alert="Error \"$2\" in file $1";
      }
    }
    if ($alert) {
      $outContext->{'filter'}=0;
      @fulllines=(@$past);
    } else {
      goto END;
    }
  }
  &newline();
  print color 'blue' if ($outContext->{'color'});
  foreach my $line (@fulllines) {
    print $line;
  }
  print color 'reset' if ($outContext->{'color'});
 END:
  if (length($out)) {
    $outContext->{'outIdle'}=time unless defined($outContext->{'outIdle'});
  } else {
    delete $outContext->{'outIdle'};
  }
  $outContext->{'outString'}=$out;
}
sub outFinish() {
  $outContext->{'outString'}.="\n" if length $outContext->{'outString'}>0;
  &outIdle();
}

# ARGV
sub initOptions {
  $optionContext={};
  $optionContext->{'includedFiles'}={};
  $optionContext->{'verbosity'}=$outContext->{'verbosity'};
  $optionContext->{'availableHelps'}={
                                      'help' => 1,
                                      'nroff' => 1,
                                      'man' => 1,
                                      'usage' => 1,
                                     };
  $optionContext->{'availableActions'}={
                                        'in' => 1,
                                        'out' => 1,
                                        'intermediary' => 1,
                                        'ignore' => 1,
                                        'clean' => 1,
                                        'build' => 1,
                                        'cli' => 1,
                                        'gitignore' => 1,
                                       };
  $optionContext->{'availableClean'}={
                                      'all' => 1,
                                      'meta' => 1,
                                      'result' => 1,
                                      'simple' => 1,
                                     };
  $optionContext->{'availableVariants'}={
                                         'pdflatex' => 1,
                                         'pdftex' => 1,
                                         'dvips' => 1,
                                         'xelatex' => 1,
                                        };
  $optionContext->{'initialOptions'}={
                                      '--help-action' => 1,
                                      '--file' => 1,
                                      '--action' => 1,
                                      '--filter' => 1,
                                      '--global' => 1,
                                     };
  $optionContext->{'standardTargets'}
    = {
       '--help' => [ '--help-action', 'help' ],
       '--in' => [ '--action', 'in' ],
       '--intermediary' => [ '--action', 'intermediary' ],
       '--generated' => [ '--action', 'out', '--action','intermediary' ],
       '-h' => [ '--help-action', 'help' ],
       '--usage' => [ '--help-action', 'usage' ],
       '--quiet' => [ '--verbosity', 'display', '0', '--verbosity','out','0','--verbosity','err','0' ],
       'help' => [ '--help-action', 'man' ],
       '--man' => [ '--help-action', 'man' ],
       '--nroff' => [ '--help-action', 'nroff' ],
       '--distclean' => [ '--clean-mode','all','--action','clean' ],
       '--clean' => [ '--action','clean' ],
       '--build' => [ '--action','build' ],
       '--index' => [  '--index-input-suffix', '.idx' , '--index-output-suffix', '.ind' ],
      };
  $optionContext->{'optionAliases'}={
                                     '--index-file-suffix' => '--index-input-suffix',
                                    };
  $optionContext->{'targets'}={};
  $optionContext->{'variant'}='pdflatex';
  $optionContext->{'chdir'}=1;
  $optionContext->{'filter'}=0;
  $optionContext->{'cleanMode'}='simple';
  $optionContext->{'manual'}=0;
  $optionContext->{'ignoreglobal'}=1;
  $progContext->{'indexCount'}=0;
}
sub checkOptionArg {
  my ($oc,$x,$option,$available,$where)=@_;
  my $optname=$option->[$x];
  &finish(1,"Wrong option: $optname must be followed by one argument") unless defined($option->[$x+1]);
  my $cat=$option->[$x+1];
  if ( $available and !defined($optionContext->{$available}->{$cat}) ) {
    &finish(1,"Wrong option: $optname must be followed by one of \"".join('" or "',sort keys %{$optionContext->{$available}}).'"');
  }
  $oc->{$where}->{$cat}=1 if $where;
  return $cat;
}
sub mergeOptions {
  my ($in,$out)=@_;
  foreach my $key (keys %$out) {
    if (ref($out->{$key}) eq 'HASH') {
      $in->{$key}={} unless defined($in->{$key});
      &mergeOptions($in->{$key},$out->{$key});
    } else {
      $in->{$key}=$out->{$key};
    }
  }
}
sub finishIndex {               # close index group
  my ($localoptions,$index)=@_;
  my $indexcount='index'.$progContext->{'indexCount'};
  return {} unless (scalar keys %$index > 0);
  $localoptions->{'index'}->{$indexcount}=$index;
  $progContext->{'indexCount'}++;
  return {};
}
sub parseOptions {
  my ($optionContext,$desc,$options)=@_;
  my $localOptions={};
  my $index={};
  my @option=@$options;
  &out(1,'init',"Treating $desc options");
  &out(2,'init',$options);
  my $x=0;
  while ($x < scalar @option) {
    my $arg=$option[$x];
    if (defined($optionContext->{'optionAliases'}->{$arg})) {
      $arg=$optionContext->{'optionAliases'}->{$arg};
    }
    if (defined($optionContext->{'nofiles'}) and defined($optionContext->{'initialOptions'}->{$arg}) ) {
      &finish(1,"Wrong option: $arg is not allowed in $desc");
    }
    if ($arg eq '--') {
      $x++;
      while (defined($option[$x])) {
        $optionContext->{'includedFiles'}->{$option[$x]}=1;
        $x++;
      }
    } elsif ($arg eq '--help-action') {
      &checkOptionArg($optionContext,$x++,$options,'availableHelps','help');
      $optionContext->{'actions'}->{'help'}=1;
    } elsif ($arg eq '--action') {
      &checkOptionArg($optionContext,$x++,$options,'availableActions','actions');
    } elsif ($arg =~ '--(\w+)' and defined($optionContext->{'verbosity'}->{$1})) {
      my $cat=$1;
      my $level=$option[++$x];
      &finish(1,"Wrong option: --$cat must be followed by an integer") unless $level =~ /^[0-9]+$/;
      $optionContext->{'verbosity'}->{$cat}=$level;
    } elsif ($arg eq '--verbosity') {
      &finish(1,"Wrong option: --verbosity must be followed by two arguments") unless defined($option[$x+2]);
      my $cat=&checkOptionArg($optionContext,$x++,$options,'verbosity');
      my $level=$option[++$x];
      &finish(1,"Wrong option: --verbosity must be followed by a category and an integer") unless $level =~ /^[0-9]+$/;
      $optionContext->{'verbosity'}->{$cat}=$level;
    } elsif ($arg eq '--variant') {
      &checkOptionArg($localOptions,$x++,$options,'availableVariants');
      $localOptions->{'variant'}=$option[$x];
    } elsif ($arg eq '--clean-mode') {
      &checkOptionArg($localOptions,$x++,$options,'availableClean');
      $optionContext->{'cleanMode'}=$option[$x];
    } elsif ($arg eq '--no-chdir') {
      $localOptions->{'chdir'}=0;
    } elsif ($arg eq '--chdir') {
      $localOptions->{'chdir'}=1;
    } elsif ($arg eq '--no-filter') {
      $localOptions->{'filter'}=0;
    } elsif ($arg eq '--filter') {
      $localOptions->{'filter'}=1;
    } elsif ($arg eq '--clean-before') {
      $localOptions->{'cleanbefore'}=1;
    } elsif ($arg eq '--manual') {
      $localOptions->{'manual'}=1;
    } elsif ($arg eq '--no-global') {
      $localOptions->{'ignoreglobal'}=1;
    } elsif ($arg eq '--global') {
      $localOptions->{'ignoreglobal'}=0;
    } elsif ($arg eq '--bibtex-file') {
      &checkOptionArg($localOptions,$x++,$options,undef,'bibfile');
    } elsif ($arg eq '--bibtex-file-suffix') {
      &checkOptionArg($localOptions,$x++,$options,undef,'bibfileSuffix');
    } elsif ($arg eq '--bibtex') {
      $localOptions->{'bibfileSuffix'}->{'.aux'}=1;
    } elsif ($arg eq '--bibtex-program') {
      my $a=&checkOptionArg(undef,$x++,$options);
      $localOptions->{'bibtexname'}=$a;
    } elsif ($arg eq '--index-style') {
      my $a=&checkOptionArg($index,$x++,$options,undef,'styleCandidate');
      $index->{'style'}={$a=>1};
      $index->{'styleIsSuffix'}=0;
    } elsif ($arg eq '--index-style-suffix') {
      my $a=&checkOptionArg($index,$x++,$options,undef,'styleCandidate');
      $index->{'style'}={$a=>1};
      $index->{'styleIsSuffix'}=1;
    } elsif ($arg eq '--index-options') {
      &checkOptionArg($index,$x++,$options,undef,'options');
    } elsif ($arg eq '--index-log') {
      my $a=&checkOptionArg($index,$x++,$options,undef,'logCandidate');
      $index->{'log'}={$a=>1};
      $index->{'logIsSuffix'}=0;
    } elsif ($arg eq '--index-log-suffix') {
      my $a=&checkOptionArg($index,$x++,$options,undef,'logCandidate');
      $index->{'log'}={$a=>1};
      $index->{'logIsSuffix'}=1;
    } elsif ($arg eq '--index-output') {
      $index=&finishIndex($localOptions,$index);
      my $a=&checkOptionArg($index,$x++,$options,undef,'outputCandidate');
      $index->{'output'}={$a=>1};
      $index->{'outputIsSuffix'}=0;
    } elsif ($arg eq '--index-output-suffix') {
      $index=&finishIndex($localOptions,$index);
      my $a=&checkOptionArg($index,$x++,$options,undef,'outputCandidate');
      $index->{'output'}={$a=>1};
      $index->{'outputIsSuffix'}=1;
    } elsif ($arg eq '--index-input') {
      &checkOptionArg($index,$x++,$options,undef,'input');
      $index->{'inputIsSuffix'}=0;
    } elsif ($arg eq '--index-input-suffix') {
      &checkOptionArg($index,$x++,$options,undef,'input');
      $index->{'inputIsSuffix'}=1;
    } elsif ($arg eq '--assume-ignore') {
      &checkOptionArg($localOptions,$x++,$options,undef,'assume-ignore');
    } elsif ($arg eq '--assume-in') {
      &checkOptionArg($localOptions,$x++,$options,undef,'assume-in');
    } elsif ($arg eq '--assume-intermediary') {
      &checkOptionArg($localOptions,$x++,$options,undef,'assume-intermediary');
    } elsif ($arg eq '--assume-out') {
      &checkOptionArg($localOptions,$x++,$options,undef,'assume-out');
    } elsif ($arg eq '--jobname-only') {
      &checkOptionArg($localOptions,$x++,$options,undef,'jobnameOnly');
    } elsif ($arg eq '--jobname') {
      my $jobname=&checkOptionArg(undef,$x++,$options);
      $index=&finishIndex($localOptions,$index);
      my $lo=$localOptions;
      $localOptions={};
      $localOptions->{'jobname'}->{$jobname}=1;
      if (defined($lo->{'jobnameOnly'})) {
        foreach my $k (keys %{$lo->{'jobnameOnly'}}) {
          $localOptions->{'jobname'}->{$k}=1;
        }
        delete $lo->{'jobnameOnly'};
      }
      if (defined($lo->{'jobname'})) {
        foreach my $k (keys %{$lo->{'jobname'}}) {
          $localOptions->{'jobname'}->{$k}=1;
        }
        delete $lo->{'jobname'};
      }
      if (defined($lo->{'jobnameLocal'})) {
        foreach my $k (keys %{$lo->{'jobnameLocal'}}) {
          $localOptions->{'jobnameLocal'}->{$k}=&clone($lo->{'jobnameLocal'}->{$k});
          delete $lo->{$k};
        }
        delete $lo->{'jobnameLocal'};
      }
      $localOptions->{'jobnameLocal'}->{$jobname}=$lo;
    } elsif (
             defined($optionContext->{'targets'}->{$arg}) or
             defined($optionContext->{'standardTargets'}->{$arg}) or
             $arg eq '--target'
            ) {
      if ($arg eq '--target') {
        $arg=&checkOptionArg($optionContext,$x++,$options,'targets');
      }
      &parseTarget($optionContext,$arg);
    } else {
      if (defined($optionContext->{'nofiles'})) {
        &finish(1,"Wrong option: unknown option $arg in $desc");
      }
      if ($arg eq '--file') {
        $arg=&checkOptionArg($optionContext,$x++,$options,undef,'includedFiles');
      }
      $index=&finishIndex($localOptions,$index);
      $optionContext->{'includedFiles'}->{$arg}=1;
      $optionContext->{'sourceLocal'}->{$arg}=&clone($localOptions);
      $localOptions={};
    }
    $x++;
  }
  $index=&finishIndex($localOptions,$index);
  if (scalar keys $localOptions > 0) {
    &out(2,'init',"Merging remaining local options");
    &mergeOptions($optionContext,$localOptions);
  }
}
sub parseTarget {
  my $optionContext=shift @_;
  my $target=shift @_;
  if (ref($optionContext->{'targets'}->{$target}) ne 'ARRAY') {
    my $targetOptions=[];
    if (defined($optionContext->{'standardTargets'}->{$target})) {
      $targetOptions=$optionContext->{'standardTargets'}->{$target};
    } else {
      my $targetName='plan/targets/'.$target;
      open TARGET,$targetName or &finish(1,"Unable to open $targetName");
      while (my $l=<TARGET>) {
        chomp $l;
        push $targetOptions,map {&decodeGoalLine($_)} split(/ /,$l);
      }
      close TARGET;
      $optionContext->{'targets'}->{$target}=$targetOptions;
    }
    &parseOptions($optionContext,'target '.$target,$targetOptions);
  } else {
    &out(2,'init',"Skipping $target because it was already invoked");
  }
}
sub parseARGV {
  &initOptions();
  &parseOptions($optionContext,'command line',[@ARGV]);
  if (scalar keys %{$optionContext->{'actions'}} == 0) {
    $optionContext->{'actions'}->{'build'}=1;
  }
  &out(3,'init','At the end of the command line');
  &out(3,'init',$optionContext);
  if (scalar keys %{$optionContext->{'includedFiles'}} == 0 and
      !defined($optionContext->{'actions'}->{'help'})) {
    &finish(3,"compile-latex needs a source file");
  }
}

# Help
sub usage {

=pod

=head2 HELP OPTIONS

B<--help>|B<-h> Generate this help (long version).

B<--usage> Generate this help (short version).

B<--man> Generate man page.

B<--nroff> Generate man page in NROFF format.

B<--help-action usage|help|man|nroff> One of the above.

The built-in target C<help> is equivalent to option B<--man>.

=cut

  ### usage ($option)
  ### Provides all kinds of textual help and stops
  my ($options)=@_;
  my $option=(sort keys %$options)[0];
  &out(1,'init',"Entering help with option $option");
  if (!defined($option)) {
    $option='usage';
  }
  my $cmd='pod2txt';
  my $release="0.6";
  my ($a,$out,$b);
  if ($option eq 'man'||$option eq 'nroff') {
    ($a,$out,$b)=@{&executeCommand('','pod2man',"$0",'--center','User commands','--release',$release)};
    if ($a==0 && $option eq 'man') {
      $out =~ s/\n.PP\n[^\n]*End of synopsis[^\n]*\n/\n/s;
      ($a,$out,$b)=@{&executeCommand($out,'nroff','-man','-')};
    }
  } else {
    ($a,$out,$b)=@{&executeCommand('','pod2text',"$0")};
  }
  if ($option eq 'usage') {
    $out =~ s/\n\s*End of synopsis.*$/\n/s;
  } elsif ($option eq 'help') {
    $out =~ s/\n\n[^\n]*End of synopsis[^\n]*\n/\n\nFor a more readable version of this text, use option --man.\n/s;
  } else {
    $out =~ s/\n.PP\n[^\n]*End of synopsis[^\n]*\n/\n/s;
  }
  if ($option ne 'man') {
    print $out;
  } else {
    open FILE,"|pager";
    print FILE $out;
    close FILE;
  }
  &finish(0);
}

# Command execution with stderr filtering
sub REAPER {
  my $child;
  while (($child = waitpid(-1, WNOHANG)) > 0) {
    &out(1,'exec',"Caught $child dying with status $?");
    $execContext->{'status'}->{$child} = $?;
    if (!defined($execContext->{'children'}->{$child})) {
      $execContext->{'unborn'}->{$child} = 1;
    } else {
      delete $execContext->{'children'}->{$child};
    }
  }
  $SIG{CHLD} = \&REAPER;        # still loathe SysV
}
sub setupCommand {
  &out(1,'init','Initialize harness for command executions');
  select(STDERR); $| = 1;
  select(STDOUT); $| = 1;
  $execContext={
                'status' => {},
                'children' => {},
                'unborn' => {},
               };
  $SIG{CHLD} = \&REAPER;
  $SIG{INT} = sub {
    foreach my $pid (keys %{$execContext->{'children'}}) {
      kill 2,$pid;
    }
  }
}
sub errorCommand {
  my $lines=$_[0];
  foreach my $line (split /\n/m,$lines) {
    chomp $line;
    if ($line =~ $outContext->{'specialprefix'}) {
      my $part=$1;
      if ($part =~ /^done:(.*)$/) {
        $part=$1;
        push $execContext->{'partiallyDone'},$part;
        next;
      }
      &out(3,'display',$part);
    } else {
      &out(1,'err',$line);
    }
  }
}
sub execCommand {
  my $line;
  &out(1,'exec','Executing '.join(' ',@_));
  my $out = gensym;
  my $err = gensym;
  $execContext->{'partiallyDone'}=[];
  my $savedstdin=dup(0);
  my $pid = open3("<&".$savedstdin,$out, $err, @_);
  die "Could not fork: $!" unless defined($pid);
  return 1 if (!$pid);
  &out(1,'exec',"Forked pid $pid");
  $execContext->{'children'}->{$pid}=1;
  my $sel= new IO::Select;
  $sel->add($err,$out);
  if (defined($execContext->{'unborn'}->{$pid})) {
    delete $execContext->{'unborn'}->{$pid};
    delete $execContext->{'children'}->{$pid};
  }
  while (scalar keys %{$execContext->{'children'}} > 0) {
    foreach my $readhandle ($sel->can_read(.5)) {
      my $length=sysread $readhandle,$line,4096;
      if ($length) {
        if (fileno($readhandle)==fileno($err)) {
          &errorCommand($line);
        } else {
          &out(1,'out',$line);
        }
      }
    }
    &outIdle();
  }
  &outFinish();
  &out(3,'exec',$execContext);
  my $status=0+$execContext->{'status'}->{$pid};
  delete $execContext->{'status'}->{$pid};
  &out(1,'exec',"Command finished with status $status");
  delete $execContext->{'outerr'};
  return $status;
}
sub executeCommand {
  # a much simpler version for the manual page
  my $in=shift @_;
  &out(1,'exec',join(' ',@_));
  my $outputtext='';
  my $errtext='';
  my $handler=undef;
  $handler=$SIG{CHLD} if defined($SIG{CHLD});
  $SIG{CHLD} = sub {} ;
  my $pid=open3(\*INPUT, \*OUTPUT, \*ERR,@_);
  print INPUT $in if $in;
  close(INPUT);
  my $done=0;
  do {
    while (<OUTPUT>) {
      $outputtext.=$_;
    }
    while (<ERR>) {
      $errtext.=$_;
    }
    $done=waitpid($pid,WNOHANG);
  } until ($done>0);
  $SIG{CHLD}=$handler if $handler;
  return [ $?, $outputtext, $errtext ];
}

# Disk Input/Output
sub fingerprintDir {
  my ($f,$env)=@_;
  opendir (my $dh, $f) || return "$f:unreadable";
  my $hashing = Digest::MD5->new;
  my @files=();
  while (my $file=readdir $dh) {
    next if $file =~ /^\./;
    push @files,$f.'/'.$file;
  }
  closedir $dh;
  @files=sort @files;
  my $data;
  foreach my $f (@files) {
    if (-d $f) {
      $data=&fingerprintDir($f,$env);
    } else {
      my ($d,$i,$m,$nl,$u,$g,$rd,$s,$at,$mt,$ct,$bs,$bl) = stat($f);
      $s='unk' unless defined($s);
      $data="$f:$s";
    }
    $hashing->add($data);
  }
  return $hashing->hexdigest;
}
sub fingerprint {
  my ($f,$env)=@_;
  my $hash='0';
  return '0' unless (-e $f);
  return &fingerprintDir($f) if (-d $f);
  open FILE,"$f" or return 'unreadable';
  my $hashing = Digest::MD5->new;
  $hashing->addfile(*FILE);
  $hash=$hashing->hexdigest;
  close FILE;
  my ($d,$i,$m,$nl,$u,$g,$rd,$s,$at,$mt,$ct,$bs,$bl) = stat($f);
  $env->{'checksumCache'}->{$f}=$hash;
  $env->{'mtimeCache'}->{$f}=$mt;
  return $hash;
}
sub fingerprintRetrofit {
  my ($f,$env)=@_;
  my $hash='0';
  return '0' unless (-e $f);
  return undef if (-d $f);
  open FILE,"$f" or return 'unreadable';
  close FILE;
  return undef unless defined $env->{'checksumCache'}->{$f};
  return undef unless defined $env->{'mtimeCache'}->{$f};
  my ($d,$i,$m,$nl,$u,$g,$rd,$s,$at,$mt,$ct,$bs,$bl) = stat($f);
  return $env->{'checksumCache'}->{$f} if ($mt eq $env->{'mtimeCache'}->{$f});
  return undef;
}
sub fingerprintArray {
  # example: $rule, 'in'
  my $context=shift @_;
  my $key=shift @_;
  my $env=shift @_;
  my @a=sort keys %{$context->{$key}};
  return 'none' unless (scalar @a);
  my $hash='';
  my $hashing = Digest::MD5->new;
  my $fp;
  foreach my $file (@a) {
    $fp=&fingerprint($file,$env);
    $hashing->add($file.$fp);
    $hash.=$file.':'.$fp;
  }
  foreach my $supp (@_) {
    $hashing->add(join('|',@$supp));
    $hash.=join('|',@$supp);
  }
  return $hash;
  return $hashing->hexdigest;
}
sub fingerprintArrayRetrofit {
  # example: $rule, 'in'
  my $context=shift @_;
  my $key=shift @_;
  my $env=shift @_;
  my $oldfp=shift @_;
  my @a=sort keys %{$context->{$key}};
  return 'none' unless (scalar @a);
  my $hash='';
  my $hashing = Digest::MD5->new;
  my $fp;
  foreach my $file (@a) {
    $fp=&fingerprintRetrofit($file,$env);
    if (!defined $fp) {
      return $oldfp;
    }
    $hashing->add($file.$fp);
    $hash.=$file.':'.$fp;
  }
  foreach my $supp (@_) {
    $hashing->add(join('|',@$supp));
    $hash.=join('|',@$supp);
  }
  return $hash;
  return $hashing->hexdigest;
}
sub outputSection {
  my ($file,$section,$data)=@_;
  my @lines=();
  my $inside=0;
  my $done=0;
  if (-f $file and -r $file) {
    open FILE,$file;
    while (my $line=<FILE>) {
      chomp $line;
      if ($line =~ /^# start automatic section for $section$/) {
        $inside=1;
        if (!$done) {
          $done=1;
          push @lines,"# start automatic section for $section";
          push @lines,$data;
          push @lines,"# stop automatic section for $section";
        }
        next;
      }
      if ($line =~ /^# stop automatic section for $section$/) {
        $inside=0;next;
      }
      next if $inside==1;
      push @lines,$line;
    }
    if (!$done) {
      push @lines,"# start automatic section for $section";
      push @lines,$data;
      push @lines,"# stop automatic section for $section";
    }
    close FILE;
  } else {
    push @lines,"# start automatic section for $section";
    push @lines,$data;
    push @lines,"# stop automatic section for $section";
  }
  open FILE,">$file";
  foreach my $line (@lines) {
    next unless defined($line);
    print FILE $line."\n";
  }
  close FILE;
}

sub encodeGoalLine {
  join('',
       map { ($_ > 127 || $_ < 32 || $_ == 37 || $_ == 59 || $_ == 58 )?
               sprintf("%%(%d)", $_) :
                 chr($_)
               } unpack("W*", &decode_utf8($_[0]))); # unpack Unicode characters
}
sub decodeGoalLine {
  my $a=$_[0];
  $a =~ s/%\(([0-9]+)\)/chr($1)/eg;
  return $a;
}

# latex-specific
sub collapseArrays {
  my $arrays=shift @_;
  my $in=$arrays->{'in'};
  my $out=$arrays->{'out'};
  my $intermediary=$arrays->{'intermediary'};
  my $ignore=$arrays->{'ignore'};
  my $result=$arrays->{'result'};
  my $meta=$arrays->{'meta'};
  $result={} unless defined $result;
  $meta={} unless defined $meta;
  my $pwd=$arrays->{'pwd'};
  my $home=$arrays->{'home'};
  # something that is both in and out is intermediary
  my $skey;
  my $waslocal={};
  my $wasnotlocal={};
  my $realhome=realpath($home);
  my $eliminateglobal=$optionContext->{'ignoreglobal'};
  foreach my $array ($in,$out,$intermediary,$ignore,$result,$meta) {
    foreach my $key (keys %$array) {
      $skey=$key;
      if ($skey=~m|^/|) {
        $skey=realpath($skey);
      } else {
        $skey=realpath($pwd.'/'.$skey);
        $waslocal->{$skey}=1;
      }
      if ($key ne $skey) {
        delete $array->{$key};
        $array->{$skey}=1;
      }
    }
  }
  foreach my $key (keys %$in) {
    if (defined($out->{$key})) {
      $intermediary->{$key}=1;
    }
  }
  foreach my $key (keys %$intermediary) {
    delete $in->{$key};
    delete $out->{$key};
  }
  foreach my $key (keys %$ignore) {
    delete $in->{$key};
    delete $out->{$key};
    delete $intermediary->{$key};
  }
  foreach my $array ($in,$out,$intermediary,$ignore,$result,$meta) {
    foreach my $key (keys %$array) {
      if (defined $waslocal->{$key}) {
        delete $array->{$key};
        $skey=File::Spec->abs2rel($key,$realhome);
        $array->{$skey}=1;
      } elsif ($eliminateglobal) {
        delete $array->{$key};
      }
    }
  }
}

sub processSourcefile {
  my ($filename)=@_;
  $filename.='.tex' unless $filename =~ /\.tex$/;
  goto FILENAME_FOUND if -r $filename;
  $filename=~ s/\.tex$//;
  goto FILENAME_FOUND if -r $filename;
  &finish(1,"Could not read neither $filename nor $filename.tex");
 FILENAME_FOUND:
  &out(1,'plan',"$_[0] is sourcefile $filename");
  &out(2,'init',"Searching $filename for options");
  $sourceContext=&clone($optionContext);
  open FILE,$filename or die "Could not open $filename";
  my @infile=();
  while (<FILE>) {
    chomp;
    next unless /^%+\s*compile-latex\s+option(s?)\s*:\s*(.*)\s*$/;
    if ($1) {
      push @infile,map {&decodeGoalLine($_)} split(/ /,$2)
    } else {
      push @infile,&decodeGoalLine($2);
    }
  }
  close FILE;
  $sourceContext->{'nofiles'}=1;
  $sourceContext->{'texsource'}=$filename;
  $sourceContext->{'fulltexsource'}=$filename;
  if (defined($sourceContext->{'sourceLocal'})) {
    my $lo=&clone($sourceContext->{'sourceLocal'});
    delete($sourceContext->{'sourceLocal'});
    if (defined($lo->{$_[0]})) {
      &mergeOptions($sourceContext,$lo->{$_[0]});
    }
  }
  &parseOptions($sourceContext,'sourcefile '.$filename,\@infile);
  &out(3,'init','At the end of the source file');
  &out(3,'init',$sourceContext);
  my $defaultjobname=$filename;
  my $homedir = realpath(getcwd);
  $sourceContext->{'pwd'}=$homedir;
  $sourceContext->{'home'}=$homedir;
  my $targetdir = realpath($filename);
  my ($volume,$directories,$file) = File::Spec->splitpath( $targetdir );
  my $dir = File::Spec->catdir($volume,$directories);
  $sourceContext->{'localdir'}='';
  if ($sourceContext->{'chdir'}) {
    &out(1,'exec',"chdir to $dir");
    chdir $dir;
    $sourceContext->{'texsource'}=$file;
    $sourceContext->{'pwd'}=$dir;
    $sourceContext->{'localdir'}=$dir.'/';
    $defaultjobname=$file;
  }
  $defaultjobname=~s/\.tex$//g;
  my $metadir='.compile-latex';
  if ( (-e $metadir or -l $metadir) and ! -d $metadir) {
    &finish(1,"Could not create metadata directory $metadir: something exists");
  } elsif (! (-e $metadir and -l $metadir)) {
    make_path($metadir);
    &finish(1,"Could not create metadata directory $metadir") unless -d $metadir;
  }
  $sourceContext->{'metadir'}=$metadir;
  $sourceContext->{'defaultjobname'}=$defaultjobname;
  if (scalar keys %{$sourceContext->{'jobname'}} == 0) {
    $sourceContext->{'jobname'}->{$defaultjobname}=1;
  }
  $sourceContext->{'class'}="Compiling $filename";
  foreach my $jobname (sort keys %{$sourceContext->{'jobname'}}) {
    processJob($jobname);
  }
  if ($sourceContext->{'chdir'}) {
    &out(1,'exec',"chdir to $homedir");
    chdir $homedir;
  }
}

sub processJob {
  my ($jobname)=@_;
  my $plans={};
  foreach my $plankey ('pre','run','post') {
    $plans->{$plankey}={'order'=>[]};
  }
  my $env=&clone($sourceContext);
  if (defined($env->{'jobnameLocal'})) {
    my $lo=&clone($env->{'jobnameLocal'});
    delete($env->{'jobnameLocal'});
    if (defined($lo->{$_[0]})) {
      &mergeOptions($env,$lo->{$_[0]});
    }
  }
  &out(3,'init','At the end of the job selection');
  &out(3,'init',$env);
  if (scalar keys %{$env->{'jobnameOnly'}}) {
    if (!defined($env->{'jobnameOnly'}->{$jobname})) {
      &out(1,'init',"Skipping $jobname");
      return;
    }
  }
  &parseOptions($env,'non-manual',['--index']) unless ($env->{'manual'});
  $env->{'meta'}=File::Spec->catdir($env->{'metadir'},$jobname);
  make_path($env->{'meta'});
  # remove dirpart
  $env->{'stem'}=$jobname;
  # create metadatadir
  my $localdir=($env->{'localdir'}?$env->{'localdir'}:'.');
  my $localdirprefix=($env->{'localdir'}?$env->{'localdir'}.'/':'');
  # if (opendir CURRENTDIR,$localdir) {
  #   my @matches = grep { /^$env->{'stem'}/ && -f $localdirprefix.$_ } readdir(CURRENTDIR);
  #   closedir CURRENTDIR;
  #   foreach my $anticipate (@matches) {
  #     &out(1,'dev',"Anticipating $localdirprefix$anticipate");
  #     &fingerprint($localdirprefix.$anticipate,$env);
  #     &out(1,'dev',$env->{'mtimeCache'});
  #   }
  # }
  &buildLatex($env,$plans);
  &buildIndices($env,$plans);
  &buildBibs($env,$plans);
  foreach my $plankey ('pre','run','post') {
    foreach my $elem (@{$plans->{$plankey}->{'order'}}) {
      &loadPlanPart($env,$plans->{$plankey},$elem);
    }
  }
  if (defined($env->{'actions'}->{'build'})) {
    my $done=0;
    my $class='Processing '.$env->{'texsource'};
    $class.=" as $jobname" if $jobname ne $env->{'defaultjobname'};
    &out(1,'display',$class);
    my $counter=1;
    foreach my $plankey ('pre','run','post') {
      $done=0;
      while (!$done) {
        ($done,$counter)=&runPlanParts($env,$plans->{$plankey},"cycle $counter",$counter);
      }
    }
    &out(3,'display','done');
  }
  if (
      defined($env->{'actions'}->{'out'}) or
      defined($env->{'actions'}->{'in'}) or
      defined($env->{'actions'}->{'intermediary'}) or
      defined($env->{'actions'}->{'ignore'}) or
      defined($env->{'actions'}->{'clean'}) or
      defined($env->{'actions'}->{'gitignore'})
     ) {
    my $array={'in'=>{},'out'=>{},'intermediary'=>{},'ignore'=>{}};
    foreach my $plankey ('pre','run','post') {
      foreach my $elem (@{$plans->{$plankey}->{'order'}}) {
        next if exists($plans->{$plankey}->{$elem}->{'disabled'});
        foreach my $i ('in','out','intermediary','ignore') {
          &addHashInPlace($array->{$i},$plans->{$plankey}->{$elem}->{$i});
        }
      }
    }
    $array->{'home'}=$env->{'home'};
    $array->{'pwd'}=$env->{'pwd'};
    $array->{'ignore'}->{$env->{'meta'}}=1;
    $array->{'meta'}->{$env->{'meta'}}=1;
    $array->{'result'}->{$env->{'outputFile'}}=1;
    &collapseArrays($array);
    my $xresult=(keys %{$array->{'result'}})[0];
    if (defined($env->{'actions'}->{'clean'}) or
        defined($env->{'actions'}->{'gitignore'})
       ) {
      my $kkey=$env->{'fulltexsource'};
      $kkey.="/$jobname" if ($jobname ne $env->{'defaultjobname'});
      if (!defined($progContext->{'gitignore'}->{$kkey})) {
        $progContext->{'gitignore'}->{$kkey}={};
      }
      foreach my $i ('out','intermediary','ignore') {
        &addHashInPlace($progContext->{'gitignore'}->{$kkey},$array->{$i});
      }
      my $output=$env->{'outputFile'};
      $progContext->{'latexresult'}->{$xresult}=1;
      $progContext->{'metadirs'}->{(keys %{$array->{'meta'}})[0]}=1;
    }
    foreach my $i ('in','out','intermediary','ignore') {
      if (defined($env->{'actions'}->{$i})) {
        &addHashInPlace($progContext->{$i},$array->{$i});
      }
    }
  }
  if (defined($env->{'actions'}->{'cli'})) {
    my @args=('PROGNAME');
    foreach my $from ('in','intermediary','out','ignore') {
      foreach my $key (sort keys %{$plans->{'run'}->{'latex'}->{$from}}) {
        push @args,"--assume-$from",&encodeGoalLine($key) if ($from ne 'in' or $key ne $env->{'texsource'}) and ($from ne 'out' or $key ne $env->{'outputLatex'});
      }
    }
    if ($env->{'manual'}) {
      my $any=1;
      my $stem=$env->{'stem'};
      foreach my $key (keys %{$plans->{'run'}->{'updateBibs'}->{'allbibs'}}) {
        if ($any) {
          $any=0;push @args,'--manual';
        }
        ;
        if ($key eq "$stem.aux") {
          push @args,'--bibtex';
        } elsif ($key=~/^$stem(.*)$/) {
          push @args,'--bibtex-file-suffix',&encodeGoalLine($1);
        } else {
          push @args,'--bibtex-file',&encodeGoalLine($key);
        }
      }
    }
    foreach my $key (keys %{$plans->{'run'}->{'allIndexes'}}) {
      my @indexargs=@{$plans->{'run'}->{$key}->{'cli'}};
      push @args,@indexargs if scalar @indexargs>1;
      push @args,@indexargs if scalar @indexargs == 1 and $env->{'manual'};
    }
    push @args,'--jobname',&encodeGoalLine($jobname) if ($jobname ne $env->{'defaultjobname'});
    push @args,'--jobname-only',&encodeGoalLine($jobname) if ($jobname ne $env->{'defaultjobname'});
    push @args,$env->{'fulltexsource'};
    $progContext->{'cli'}->{&encodeGoalLine($env->{'fulltexsource'}).';'.$jobname.';'.&encodeGoalLine($jobname)}=join(' ',@args);
  }
}

sub runPlanParts {
  my ($env,$plan,$subclass,$counter)=@_;
  my $alldone=1;
  &out(3,'plan',$plan);
  my $order=$plan->{'order'};
  $counter++ if scalar @$order;
  foreach my $elem (@$order) {
    my $part=$plan->{$elem};
    if (!exists($part->{'always'})) {
      my $fingerprintIn=&fingerprintArray($part,'in',$env);
      my $fingerprintOut=&fingerprintArray($part,'out',$env);
      my $fingerprintIntermediary=&fingerprintArray($part,'intermediary',$env);
      my $fp="$fingerprintIn $fingerprintOut $fingerprintIntermediary";
      my $oldfp=join(' ',$part->{'fingerprint-in'},$part->{'fingerprint-out'},$part->{'fingerprint-intermediary'});
      if ($oldfp eq $fp) {
        &out(1,'plan',"Skipping $elem");
        next;
      } else {
        &out(2,'plan',"Not skipping $elem because\n$fp is not\n$oldfp");
      }
      $part->{'fingerprint-in'}=$fingerprintIn;
      $part->{'fingerprint-intermediary'}=$fingerprintIntermediary;
    }
    &out(1,'plan',"Trying $elem");
    my $return; # 1 should be returned if nothing was done, 0 if something was done
    {
      no strict 'refs';
      $return=&{$part->{'callback'}}($env,$plan,$part,$subclass);
    }
    &savePlanPart($env,$plan,$elem);
    $alldone=0 unless $return;
    $subclass=undef unless $alldone;
  }
  return ($alldone,$counter);
}

sub buildLatex {
  my ($env,$plans)=@_;
  my $runPlan=$plans->{'run'};
  my $postPlan=$plans->{'post'};
  my $p=$env->{'variant'};
  $env->{'latexmode'}='latex';
  if ($p eq 'pdflatex' or $p eq 'tex' or $p eq 'pdftex') {
    $env->{'latexname'}='pdflatex';
    $env->{'dviname'}='';
    $env->{'outputFile'}=$env->{'stem'}.'.pdf';
  } elsif ($p eq 'dvips' or $p eq 'dvips+latex' or $p eq 'dvips+tex') {
    $env->{'dvicallback'}='dvipsCallback';
    $env->{'latexname'}='latex';
    $env->{'dviname'}='dvips';
    $env->{'inputDviFile'}=$env->{'stem'}.'.dvi';
    $env->{'outputFile'}=$env->{'stem'}.'.ps';
  } elsif ($p eq 'dvipdf' or $p eq 'dvipdf+latex' or $p eq 'dvipdf+tex') {
    $env->{'dvicallback'}='dvipsCallback';
    $env->{'latexname'}='latex';
    $env->{'dviname'}='dvipdf';
    $env->{'inputDviFile'}=$env->{'stem'}.'.dvi';
    $env->{'outputFile'}=$env->{'stem'}.'.pdf';
  } elsif ($p eq 'dvipdfm' or $p eq 'dvipdfm+latex' or $p eq 'dvipdfm+tex') {
    $env->{'dvicallback'}='dvipsCallback';
    $env->{'latexname'}='latex';
    $env->{'dviname'}='dvipdfm';
    $env->{'inputDviFile'}=$env->{'stem'}.'.dvi';
    $env->{'outputFile'}=$env->{'stem'}.'.pdf';
  } elsif ($p eq 'xelatex' or $p eq 'xetex') {
    $env->{'dvicallback'}='dvipsCallback';
    $env->{'latexname'}='xelatex';
    $env->{'latexargs'}=['--no-pdf'];
    $env->{'dviname'}='xdvipdfmx';
    $env->{'inputDviFile'}=$env->{'stem'}.'.xdv';
    $env->{'outputFile'}=$env->{'stem'}.'.pdf';
  } elsif ($p eq 'lualatex' or $p eq 'luatex') {
    $env->{'latexname'}='lualatex';
    $env->{'dviname'}='';
    $env->{'outputFile'}=$env->{'stem'}.'.pdf';
  } else {
    # unknown chain
    &finish(1,"Unknown latex variant: $p");
  }
  if ($p =~ /[^a]tex/) {
    $env->{'latexmode'}='tex';
    $env->{'latexname'}=~ s/latex/tex/g;
  }
  my $latex={
             'in' => { $env->{'texsource'} => 1},
             'callback' => 'latexCallback',
             'command' => [split(/ /,$env->{'latexname'}),
                           '--file-line-error',
                           '--recorder',
                           '--jobname',$env->{'stem'},
                           (defined $env->{'latexargs'}?@{$env->{'latexargs'}}:()),
                           $env->{'texsource'}
                          ],
            };
  if ($env->{'latexmode'} eq 'latex') {
    $latex->{'intermediary'}={$env->{'stem'}.'.aux'=>1},
  }
  if (defined $env->{'inputDviFile'}) {
    $latex->{'out'}={$env->{'inputDviFile'}=>1};
    $env->{'outputLatex'}=$env->{'inputDviFile'};
  } else {
    $latex->{'out'}={$env->{'outputFile'}=>1};
    $env->{'outputLatex'}=$env->{'outputFile'};
  }
  $latex->{'ignore'}->{$env->{'stem'}.".log"}=1;
  $latex->{'ignore'}->{$env->{'stem'}.".fls"}=1;
  foreach my $from ('in','out','intermediary','ignore') {
    if (defined $env->{"assume-$from"}) {
      my $fromH=$env->{"assume-$from"};
      foreach my $key (keys %$fromH) {
        $latex->{$from}->{$key}=1;
      }
    }
  }
  foreach my $key (keys %{$latex->{'ignore'}}) {
    foreach my $xx ('in','out','intermediary') {
      delete $latex->{$xx}->{$key} if exists $latex->{$xx}->{$key};
    }
  }
  $runPlan->{'latex'}=$latex;
  push $runPlan->{'order'},'latex';
  if ($env->{'cleanbefore'}) {
    $latex->{'always'}=1;
  }
  if (defined $env->{'inputDviFile'}) {
    my $dvi={
             'in' => { $env->{'inputDviFile'} => 1 },
             'out' => { $env->{'outputFile'} => 1 },
             'callback' => $env->{'dvicallback'},
             'command' => [ $env->{'dviname'},
                            '-o', $env->{'outputFile'},
                            $env->{'inputDviFile'}
                          ],
            };
    $postPlan->{'dvi'}=$dvi;
    push $postPlan->{'order'},'dvi';
  }
}
sub buildIndices {
  my ($env,$plans)=@_;
  my $runPlan=$plans->{'run'};
  foreach my $key (keys %{$env->{'index'}}) {
    &buildIndex($env,$runPlan,$env->{'index'}->{$key});
  }
}
sub buildIndex {
  my ($env,$runPlan,$index)=@_;
  my $style=0;
  my ($in,$out,$sty,$log)=();
  my @args=();
  if (!defined($index->{'input'})) {
    $index->{'input'}={'.idx'=>1};
    $index->{'inputIsSuffix'}=1;
  }
  if (!defined($index->{'output'})) {
    $index->{'output'}={'.ind'=>1};
    $index->{'outputIsSuffix'}=1;
  }
  if (!defined($index->{'log'})) {
    $index->{'log'}={'.ilg'=>1};
    $index->{'logIsSuffix'}=1;
  }
  if (defined($index->{'style'})) {
    $style=1;
  } else {
    $index->{'style'}={'.mst'=>1};
    $index->{'styleIsSuffix'}=1;
  }
  if ($index->{'inputIsSuffix'}) {
    my $key=(keys $index->{'input'})[0];
    $in=$env->{'stem'}.$key;
    push @args,'--index-input-suffix',$key;
  } else {
    my $key=(keys $index->{'input'})[0];
    $in=&decodeGoalLine($key);
    push @args,'--index-input',$key;
  }
  if ($index->{'logIsSuffix'}) {
    my $key=(keys $index->{'log'})[0];
    $log=$env->{'stem'}.$key;
    push @args,'--index-log-suffix',$key unless $key eq '.ilg';
  } else {
    my $key=(keys $index->{'log'})[0];
    $log=&decodeGoalLine($key);
    push @args,'--index-log',$key;
  }
  if ($index->{'outputIsSuffix'}) {
    my $key=(keys $index->{'output'})[0];
    $out=$env->{'stem'}.$key;
    push @args,'--index-output-suffix',$key unless $key eq '.ind';
  } else {
    my $key=(keys $index->{'output'})[0];
    $out=&decodeGoalLine($key);
    push @args,'--index-output',$key;
  }
  if ($index->{'styleIsSuffix'}) {
    my $key=(keys $index->{'style'})[0];
    $sty=$env->{'stem'}.$key;
    push @args,'--index-style-suffix',$key unless $key eq '.mst';
  } else {
    my $key=(keys $index->{'style'})[0];
    $sty=&decodeGoalLine($key);
    push @args,'--index-style',$key;
  }
  if (join(' ',@args) eq '--index-input-suffix .idx') {
    @args=('--index');
  }
  my $action={
              'in' => { $in=>1,$sty=>1 },
              'out' => { $out=>1 },
              'ignore' => {$log => 1},
              'intermediary' => {},
              'callback' => 'indexCallback',
              'style' => $style,
              'styleFile'=> $sty,
              'sourceFile'=> $in,
              'command' => ['makeindex','-o',$out],
              'cmdname' => 'makeindex '.(keys $index->{'input'})[0].'=>'.(keys $index->{'output'})[0],
              'cli' => \@args,
             };
  push $action->{'command'},'-s',$sty if ($style);
  push $action->{'command'},'-t',$log if ($log);
  push $action->{'command'},split(/ /,$index->{'options'}) if exists($index->{'options'});
  push $action->{'command'},$in;
  my $xkey="makeindex_$out";
  $runPlan->{$xkey}=$action;
  push $runPlan->{'order'},$xkey;
  $runPlan->{'allIndexes'}->{$xkey}=1;
}
sub buildBibs {
  my ($env,$plans)=@_;
  my $runPlan=$plans->{'run'};
  if ($env->{'manual'} != 1) {
    push $runPlan->{'order'},'autoBib';
    $runPlan->{'autoBib'}={
                           'command'=> ['autoBib'],
                           'always' => 1,
                           'callback' => 'autoBibCallback'
                          };
  }
  push $runPlan->{'order'},'updateBibs';
  $runPlan->{'updateBibs'}={
                            'command'=> ['updateBibs'],
                            'always' => 1,
                            'callback' => 'updateBibsCallback',
                            'allbibs' => {},
                           };
  foreach my $key (keys %{$env->{'bibfile'}}) {
    &buildBib($env,$runPlan,$key);
  }
  foreach my $key (keys %{$env->{'bibfileSuffix'}}) {
    &buildBib($env,$runPlan,$env->{'stem'}.$key);
  }
}
sub buildBib {
  my ($env,$runPlan,$bib)=@_;
  my $stem=$bib;
  $stem=~s/\.aux$//g;
  $bib="$stem.aux";
  my $key='bib'.$bib;
  my $fakebib=$bib;
  if ($stem eq $env->{'stem'}) {
    $fakebib=File::Spec->catfile($env->{'meta'},"auxbib");
  }
  my $bibpart={
               'in' => {$fakebib => 1},
               'out'=> {"$stem.bbl"=>1},
               'ignore' => {"$stem.blg"=>1},
               'intermediary' => {},
               'callback' => 'bibCallback',
              };
  $env->{'bibtexname'}="bibtex" unless (exists $env->{'bibtexname'});
  my $command=[map {&decodeGoalLine($_)} split(/ /,$env->{'bibtexname'})];
  push $command,'-terse' if ($env->{'filter'});
  push $command,$stem;
  $bibpart->{'command'}=$command;
  $bibpart->{'cmdname'}="bibtex $stem";
  if (-f $bib) {
    my $copy=0;
    if ($fakebib ne $bib) {
      $copy=1;
      open FINGERFILE,'>',$fakebib;
    }
    if (!open FILE,$bib) {
      &out(1,'err',"Could not open $bib for reading");
      goto skip;
    }
    my $bibdata={};
    my $bibstyle=undef;
    while (<FILE>) {
      if ($copy and /^\\([a-z]+)/) {
        print FINGERFILE $_ if ($1 eq 'bibdata' or $1 eq 'citation' or $1 eq 'bibstyle');
      }
      if (/^\\bibstyle{(.*)}$/) {
        my $bibdataf=$1;
        $bibdataf=~s/\.bst$//g;
        $bibstyle=$bibdataf;
      } elsif (/^\\bibdata{(.*)}$/) {
        my $bibdataf=$1;
        $bibdataf=~s/\.bib$//g;
        $bibdata->{$bibdataf}=1;
      }
    }
    close FINGERFILE if ($copy);
    goto skip unless defined($bibstyle);
    goto skip unless scalar keys %$bibdata;
    my $bibstylef=&kpsewhich('bibtex',$bibstyle.'.bst');
    $bibpart->{'in'}->{$bibstylef}=1 if defined $bibstylef;
    foreach my $bkey (keys %$bibdata) {
      my $bibdataf=&kpsewhich('bibtex',$bkey.'.bib');
      $bibpart->{'in'}->{$bibdataf}=1 if $bibdataf;
    }
    $bibpart->{'home'}=$bibpart->{'pwd'}=getcwd();
    &collapseArrays($bibpart);
  }
 skip:
  push $runPlan->{'order'},$key unless exists $runPlan->{$key};
  $runPlan->{$key}=$bibpart;
  $runPlan->{'updateBibs'}->{'allbibs'}->{$bib}=1;
  &loadPlanPart($env,$runPlan,$key);
}
sub kpsewhich {
  my ($progname,$file)=@_;
  my ($a,$out,$b)=@{&executeCommand('','kpsewhich','-progname',$progname,$file)};
  chomp $out;
  return $out if ($a == 0);
  return undef;
}
sub updateBibsCallback {
  my ($env,$plan,$part,$subclass)=@_;
  foreach my $key (keys %{$part->{'allbibs'}}) {
    &buildBib($env,$plan,$key,1);
  }
  return 1;
}
sub autoBibCallback {
  my ($env,$plan,$part,$subclass)=@_;
  my @outlatexfiles=(keys %{$plan->{'latex'}->{'out'}},keys %{$plan->{'latex'}->{'intermediary'}});
  my $bibfiles={};
  foreach my $file (@outlatexfiles) {
    open FILE,$file or next;
    my $status=0;
    while (<FILE>) {
      if (/^\\bibstyle/ or /^\\bibcite/ or /^\\bibdata/ or /^\\citation/) {
        $status=$status|2;
      } else {
        $status=$status|1;
      }
    }
    close FILE;
    $bibfiles->{$file}=1 if $status == 2;
    $bibfiles->{$file}=1 if $file eq $env->{'stem'}.'.aux' and $status == 3;
  }
  foreach my $key (keys %$bibfiles) {
    $plan->{'updateBibs'}->{'allbibs'}->{$key}=1;
  }
  return 1;
}
sub bibCallback {
  my ($env,$plan,$part,$subclass)=@_;
  &out(2,'display',$subclass) if defined($subclass);
  &out(3,'display',$part->{'cmdname'});
  my @command=@{$part->{'command'}};
  my $status=&execCommand(@command);
  if ($status) {
    &finish(1,$env->{'cmdname'}." failed with status $status");
  }
  $part->{'fingerprint-out'}=&fingerprintArray($part,'out',$env);
  return 0;
}
sub indexCallback {
  my ($env,$plan,$part,$subclass)=@_;
  if (! -f $part->{'sourceFile'}) {
    $part->{'disabled'}=1;
    return 1;
  }
  delete $part->{'disabled'} if exists($part->{'disabled'});
  &out(2,'display',$subclass) if defined($subclass);
  &out(3,'display',$part->{'cmdname'});
  if ($part->{'style'} and ! -f $part->{'styleFile'}) {
    &finish(1,"Mandatory style file for makeindex $part->{'styleFile'} not found");
  }
  my @command=@{$part->{'command'}};
  if ($env->{'filter'}) {
    splice @command,-1,0,'-q';
  }
  my $status=&execCommand(@command);
  if ($status) {
    &finish(1,$env->{'cmdname'}." failed with status $status");
  }
  $part->{'fingerprint-out'}=&fingerprintArray($part,'out',$env);
  return 0;
}
sub latexCallback {
  my ($env,$plan,$part,$subclass)=@_;
  &out(2,'display',$subclass) if defined($subclass);
  &out(3,'display',$env->{'latexname'});
  $outContext->{'filter'}=$env->{'filter'};
  if ($part->{'always'}) {
    delete $part->{'always'};
    if ($env->{'cleanbefore'}) {
      foreach my $source ('out','intermediary') {
        foreach my $file (keys %{$part->{$source}}) {
          unlink $file if (-f $file);
        }
      }
    }
    foreach my $source ('in','out','intermediary') {
      $part->{'fingerprint-'.$source}=&fingerprintArray($part,$source,$env);
    }
  }
  my $status=&execCommand(@{$part->{'command'}});
  if ($status) {
    &finish(1,"TeX failed with status $status");
  }
  # Reevaluate inputs and outputs
  my ($out,$in,$intermediary,$pwd)=({},{},{},undef);
  open FILE,$env->{'stem'}.".fls" or die 'Input/output list was not generated!';
  my $line;
  while ($line=<FILE>) {
    chomp $line; 
    if ($line=~/^INPUT (.*)$/) {
      if (defined $out->{$1}) {
        $intermediary->{$1}=1;
      } else {
        $in->{$1}=1;
      }
    } elsif ($line=~/^OUTPUT (.*)$/) {
      if (defined $in->{$1}) {
        $intermediary->{$1}=1;
      } else {
        $out->{$1}=1;
      }
    } elsif ($line=~/^PWD (.*)$/) {
      $pwd=$1;
    } else {
      &out(1,'err',"Unexpected line \"$line\" in input/output list\n");
    }
  }
  close FILE;
  $out->{$env->{'stem'}.".fls"}=1;
  my $arrays={'in'=>$in,'out'=>$out,'intermediary'=>$intermediary,'pwd'=>$pwd,'home'=>$pwd};
  foreach my $source ('out','intermediary','ignore') {
    foreach my $f (keys %{$part->{$source}}) {
      if (-f $f and !exists($part->{'ignore'}->{$f})) {
        next if defined($arrays->{$source}->{$f});
        my $x=$env->{'checksumCache'}->{$f};
        $x='undef' if (!defined $x);
        my $xx=&fingerprint($f,$env);
        if ($x eq $xx) {
          $arrays->{$source}->{$f}=1;
        }
      }
    }
  }
  &collapseArrays($arrays);
  foreach my $key (keys %{$part->{'ignore'}}) {
    foreach my $x ($in,$out,$intermediary) {
      delete $x->{$key} if exists $x->{$key};
    }
  }
  $part->{'in'}=$in;
  $part->{'out'}=$out;
  $part->{'intermediary'}=$intermediary;
  $part->{'fingerprint-out'}=&fingerprintArray($part,'out',$env);
  $part->{'fingerprint-in'}=&fingerprintArrayRetrofit($part,'in',$env,$part->{'fingerprint-in'});
  $part->{'fingerprint-intermediary'}=&fingerprintArrayRetrofit($part,'intermediary',$env,$part->{'fingerprint-intermediary'});
  return 0;
}
sub dvipsCallback {
  # just execute the dvi command line
  # no dependencies adjusted
  my ($env,$plan,$part,$subclass)=@_;
  &out(2,'display',$subclass) if defined($subclass);
  &out(3,'display',$env->{'dviname'});
  my @command=@{$part->{'command'}};
  if ($env->{'filter'}) {
    splice @command,1,0,'-q';
  }
  my $status=&execCommand(@command);
  if ($status) {
    &finish(1,$env->{'dviname'}.' failed with status '.$status);
  }
  $part->{'fingerprint-out'}=&fingerprintArray($part,'out',$env);
  $part->{'fingerprint-in'}=&fingerprintArrayRetrofit($part,'in',$env,$part->{'fingerprint-in'});
  $part->{'fingerprint-intermediary'}=&fingerprintArrayRetrofit($part,'intermediary',$env,$part->{'fingerprint-intermediary'});
  return 0;
}

sub savePlanPart {
  my ($env,$plan,$elem)=@_;
  my $part=$plan->{$elem};
  my $filename=File::Spec->catfile($env->{'meta'},$elem);
  open FILE,">$filename" or die "Could not save metadata to $filename";
  do {
    local $Data::Dumper::Indent=0;
    print FILE Data::Dumper->Dump([$part],['part']);
  };
  close FILE;
}
sub loadPlanPart {
  my ($env,$plan,$elem)=@_;
  my $xpart=$plan->{$elem};
  my $hashing = Digest::MD5->new;
  $hashing->add(join(' ',@{$xpart->{'command'}}));
  $xpart->{'fingerprintCmd'}=$hashing->hexdigest;
  my $filename=File::Spec->catfile($env->{'meta'},$elem);
  $xpart->{'fingerprint-out'}='new';
  $xpart->{'fingerprint-intermediary'}='new';
  $xpart->{'fingerprint-in'}='new';
  if (-f $filename) {
    open FILE,"$filename" or die "Could not save metadata to $filename";
    my $string=<FILE>;
    close FILE;
    my $part;
    do {
      eval $string;
    };
    foreach my $i ('out','in','intermediary') {
      $xpart->{$i}={} unless defined($xpart->{$i});
      &addHashInPlace($xpart->{$i},$part->{$i});
    }
    if ($part->{'fingerprintCmd'} eq $xpart->{'fingerprintCmd'}) {
      &out(1,'plan','Integrating saved fingerprints');
      if (exists($part->{'disabled'})) {
        $xpart->{'disabled'}=$part->{'disabled'};
      }
      $xpart->{'fingerprint-out'}=$part->{'fingerprint-out'};
      $xpart->{'fingerprint-intermediary'}=$part->{'fingerprint-intermediary'};
      $xpart->{'fingerprint-in'}=$part->{'fingerprint-in'};
    }
  }
}

if ('' cmp 'DOC FOOTER') {

=pod

=head1 BUGS OR FEATURES

A more powerful but linux-only version of this program did exist and
used strace to find out all dependencies. This may come back. This will
probably not work under BSD-like (and even more under non-Unix-like)
environments.

dvips do not allow proper dependencies listing.

This program is untested with Miktex.

This program will probably not work under non-Unix-like environments.

If some intermediary file is generated at one step, and not regenerated
if already present (such as with the C<filecontents> package), and the
metadata is deleted but not the file, then C<compile-latex> will not be
able to see that this file could be regenerated. This should not happen
when cleaning with the B<clean> action.

No tests were conducted with something else than bibtex and makeindex.

When using some \write18 commands, the dependency tracking is wrong
(unless the strace option is activated). Some recent auto-makeindex and
auto-bibtex functionality are likely useless (but not harmful).

=head1 AUTHOR

Copyright Jean-Christophe Dubacq 2013

=head1 COPYING

This work is licensed under the 2-clause BSD licence. It is explicitly stated
here that the license does not extend to the data managed by the
program, in case anyone had doubts.

=head1 TODO

Shorthands for useful options.

Fix documentation (--variant, --assume-*, ...)

Fix (x)dvipdfm(x) dependencies reading from -v option

Test on OSX

Retrofix fingerprintIn if one input was added/deleted, and we have a working cache of it?

=cut

}
